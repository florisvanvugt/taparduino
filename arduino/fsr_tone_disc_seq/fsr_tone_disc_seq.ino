// -*- Mode:c -*-
// The above incantation tells emacs to do C style syntax highlighting

/* Use FSR to create a sound on an audio jack from a PWM pin

Connect the audio jack to digital pin 9 through a 1kOhm resistor

Ensure that the Arduino (or microcontroller) used has a PWM pin for this arrangement.

Connect one end of FSR to 5V, the other end to Analog 0.
Then connect one end of a 10K resistor from Analog 0 to ground

*/

//////////////////////////////////// load libraries
#include <avr/pgmspace.h>
#include <avr/sleep.h>

////////////////////////////////////  set variables 
int fsrAnalogPin = 0; // FSR is connected to analog 0
int fsrReading;      // the analog reading from the FSR resistor divider
int threshold = 20; // the FSR threshold necessary to make a sound (ON)
int low_thresh = 10; // where the FSR reading must go to to be OFF
int time_thresh = 40; // set a time threshold for how long to wait until another sound can be made
int offset_thresh = 40; // set a time threshold for how long to wait after depression (prevent double taps)
unsigned long time_tol = 0; // preset the exact time from which it is ok to make another sound
unsigned long timeStamp=0; // timestamp for Arduino
unsigned long prevt=-1; // the previous time value to ensure sample rate of 1000Hz
int cur_on = 0; // say if the FSR is "on" or "off"

// variables for discrete data
unsigned long cur_onset = 0; // preset current onset time
unsigned long cur_offset = 0; // preset current offset time
int max_force = 0; // preset maximum FSR reading

// variables for tone condition
//int tone_freq = 1046.5; // defines the frequency (i.e., pitch) of the tone (in Hz)
//int tone_dur = 20; // defines the duration of the tone
unsigned long tone_tol=0; // presets the tone offset time

// variables for tone sequences
int all_tones[30] = {220, 220, 233.08, 261.63, 261.63, 233.08, 220, 196, 174.61, 174.61, 196, 220, 220, 196, 196, 220, 220, 233.08, 261.63, 261.63, 233.08, 220, 196, 174.61, 174.61, 196, 220, 196, 174.61, 174.61  };
int all_durs[30] = {200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 400, 100, 400, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 400, 100, 400  };
int all_delays[30] = {0, 0, 0, 75, 50, 50, 100, 50, 50, 50, 50, 50, 50, 25, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
int num_sounds = sizeof(all_tones)/sizeof(all_tones[0])-1;
//int all_intense[30] = { 10, 1, 5, 6, 7, 2, 3, 4, 9, 8, 7, 6, 5, 4, 3, 10, 1, 5, 6, 7, 2, 3, 4, 9, 8, 7, 6, 5, 10, 10 };
//int all_timbre[15] = { 1, 1, 1, 1, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2 };

// get first tone sequence value
int tone_freq = all_tones[0]; // defines the frequency (i.e., pitch) of the tone (in Hz)
int tone_dur = all_durs[0]; // defines the duration of the tone
int cur_del = all_delays[0]; // defines delays
int cur_pos = 0; // preset start position
//int intense = all_intense[0]; // defines the duration of the tone
//int cur_tim = all_timbre[1]; // defines timbre


/////////////////////////////// Set up lookup table for waveform generation
/*
A SQUARE WAVE lookup table. You can generate this using the example Python code here below:
sqwav = [ '0xff' for _ in range(256/2) ] + [ '0x00' for _ in range(256/2) ]
print ",".join(sqwav)
*/

static const uint8_t  sineTable[] PROGMEM =
{
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};


/* A 256-item lookup table for a SINE WAVE. Each item is encoded as a hexadecimal number, hence the 0x prefix */
/*static const uint8_t  sineTable[] PROGMEM =
{
0x80,0x83,0x86,0x89,0x8c,0x8f,0x92,0x95,
0x98,0x9c,0x9f,0xa2,0xa5,0xa8,0xab,0xae,
0xb0,0xb3,0xb6,0xb9,0xbc,0xbf,0xc1,0xc4,
0xc7,0xc9,0xcc,0xce,0xd1,0xd3,0xd5,0xd8,
0xda,0xdc,0xde,0xe0,0xe2,0xe4,0xe6,0xe8,
0xea,0xec,0xed,0xef,0xf0,0xf2,0xf3,0xf5,
0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfc,
0xfd,0xfe,0xfe,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0xfe,
0xfd,0xfc,0xfc,0xfb,0xfa,0xf9,0xf8,0xf7,
0xf6,0xf5,0xf3,0xf2,0xf0,0xef,0xed,0xec,
0xea,0xe8,0xe6,0xe4,0xe2,0xe0,0xde,0xdc,
0xda,0xd8,0xd5,0xd3,0xd1,0xce,0xcc,0xc9,
0xc7,0xc4,0xc1,0xbf,0xbc,0xb9,0xb6,0xb3,
0xb0,0xae,0xab,0xa8,0xa5,0xa2,0x9f,0x9c,
0x98,0x95,0x92,0x8f,0x8c,0x89,0x86,0x83,
0x80,0x7c,0x79,0x76,0x73,0x70,0x6d,0x6a,
0x67,0x63,0x60,0x5d,0x5a,0x57,0x54,0x51,
0x4f,0x4c,0x49,0x46,0x43,0x40,0x3e,0x3b,
0x38,0x36,0x33,0x31,0x2e,0x2c,0x2a,0x27,
0x25,0x23,0x21,0x1f,0x1d,0x1b,0x19,0x17,
0x15,0x13,0x12,0x10,0x0f,0x0d,0x0c,0x0a,
0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x03,
0x02,0x01,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,
0x02,0x03,0x03,0x04,0x05,0x06,0x07,0x08,
0x09,0x0a,0x0c,0x0d,0x0f,0x10,0x12,0x13,
0x15,0x17,0x19,0x1b,0x1d,0x1f,0x21,0x23,
0x25,0x27,0x2a,0x2c,0x2e,0x31,0x33,0x36,
0x38,0x3b,0x3e,0x40,0x43,0x46,0x49,0x4c,
0x4f,0x51,0x54,0x57,0x5a,0x5d,0x60,0x63,
0x67,0x6a,0x6d,0x70,0x73,0x76,0x79,0x7c
};
*/


/*
// A SAW WAVE

static const uint8_t  sineTable[] PROGMEM =
{
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
};

*/

////////////////////////////////////  set PWM variables and functions
// PWM output (OCR1A)
int pwmPin = 9;

// 16 bit accumulator
uint16_t phaseAccumulator = 0;
// 16 bit delta
uint16_t phaseIncrement = 0;
// DDS resolution
const uint32_t resolution =  68719;
// wavetable lookup index(upper 8 bits of the accumulator)
uint8_t index = 0;

// TIMER1 will overflow at a 62.5KHz(Sampling frequency).
// Updates the OCR1A value and the accumulator.
// Computes the next sample to be sent to the PWM.
ISR(TIMER1_OVF_vect)
{
  static uint8_t osc = 0;

  // Send oscillator output to PWM
  OCR1A = osc;

  // Update accumulator
  phaseAccumulator += phaseIncrement;
  index = phaseAccumulator >> 8;

  // Read oscillator value for next interrupt
  osc = pgm_read_byte( &sineTable[index] );

}

// Configures TIMER1 to fast PWM non inverted mode.
// Prescaler set to 1, which means that timer overflows
// every 16MHz/256 = 62.5KHz
void initPWM(void)
{
  // Set PORTB1 pin as output
  pinMode(pwmPin, OUTPUT);

  // 8-bit Fast PWM - non inverted PWM
  TCCR1A= _BV(COM1A1) | _BV(WGM10);

  // Start timer without prescaler
  TCCR1B = _BV(CS10) | _BV(WGM12);

  // Enable overflow interrupt for OCR1A
  TIMSK1 = _BV(TOIE1);

}

// Translates the desired output frequency to a phase
// increment to be used with the phase accumulator.
// The 16 bit shift is required to remove the  2^16
// scale factor of the resolution.
void setFrequency( uint16_t frequency )
{
  uint64_t phaseIncr64 =  resolution * frequency;
  phaseIncrement = phaseIncr64 >> 16;
}

// The duration of one metronome tick (in microsec)
const unsigned long TICKDURATION = tone_dur*1000;   // duration of ticks (legacy code)

// function to turn tick on
void tickOn(){
  setFrequency(tone_freq);
}

// function to turn sound off
void tickOff() {
  setFrequency( .05 ); // so that you practically don't hear anything (well below perceptual limit of humans)
}


//////////////////////////////////// SETUP
void setup() {
  Serial.begin(9600); // slow speed debugging
  //Serial.begin(1152000); // high speed debugging
  //Serial.begin(1555200); // good speed for processing (must match python code for reading!)
  
  // Initialise fast PWM
  initPWM();

  // Enable sleep mode
  set_sleep_mode(SLEEP_MODE_IDLE);

  // Set phase increment according to
  // desired OFF frequency
  tickOff();

  // Enable global interrupts
  sei();
 
}

//////////////////////////////////// LOOP
void loop(void) {
  getInfos(); // read info 
  
  if (fsrReading > threshold){
    cur_onset = timeStamp;
    time_tol = timeStamp+time_thresh;
    cur_on  = 1;
    
    while (timeStamp < time_tol) { // wait for delay time
      //if (fsrReading > max_force) max_force = fsrReading;
      getInfos(); // read info    
    }

    // play the tone
    tickOn(); // change PWM output to tone frequency
    tone_tol = timeStamp+tone_dur; // set tone off time        
    getInfos(); // read info
    
    // now let's stop it from playing again until after the time threshold and the FSR reading returns to zero    
    while (fsrReading > low_thresh) {
      getInfos(); // read info
    }
    
    cur_offset = timeStamp; // get offset time   
    collectData(); // send data   
    time_tol = timeStamp+offset_thresh; // set time until next tap can occur
    
    // now let's stop it from playing again until after the time threshold and the FSR reading returns to zero    
    while ((timeStamp < time_tol) || (fsrReading > low_thresh)) {      
      getInfos(); // read info      
   }
   
   // reset our variables
   if (cur_pos == num_sounds) {
     cur_pos = 0; 
   }
   else {
     cur_pos = cur_pos+1;      
   }
    
   tone_freq = all_tones[cur_pos]; // defines the frequency (i.e., pitch) of the tone (in Hz)
   tone_dur = all_durs[cur_pos]; // defines the duration of the tone
   cur_del = all_delays[cur_pos]; // defines delays
   
  }
  
  max_force = fsrReading;
     
}

//////////////////////////////////// FUNCTIONS
// Send data to serial port
void collectData() { 
      
  if (prevt==-1 | timeStamp!=prevt) { 
    // only send if the time has changed, that is, 
    // force the data transfer to maximum of 1000Hz.
    // Using higher sample rates can result in buffer
    // overflows and missed packets

    // Send data to the serial port (for degugging in Arduino serial manager)
    //Serial.print("Onset time = ");
    //Serial.print(cur_onset);
    //Serial.print(" Offset time = ");
    //Serial.print(cur_offset);
    //Serial.print(" Maximum force = ");
    //Serial.print(max_force);    
    //Serial.print("\n");
    
    // Send data to the serial port
    Serial.print("B"); // signal packet start (hardcoded)
    sendBinary(cur_onset); // send onset time
    sendBinary(cur_offset); // send offset time
    sendBinary(max_force); // send max FSR reading
    Serial.print("E"); // signal packet end (hardcoded)
    prevt=timeStamp; // send previous time marker
  }    
}

// get FSR and timing info, and turn off the sound at end of tone duration
void getInfos() {
  fsrReading = analogRead(fsrAnalogPin); // read FSR
  timeStamp = millis(); // get time (in milliseconds)       
  if (timeStamp>=tone_tol) {
    tickOff(); // turn sound off
    phaseAccumulator = 0; // reset phase
  }
  if (fsrReading > max_force) max_force = fsrReading;
  if ((cur_on==1) && (fsrReading <= low_thresh)) {
    cur_offset = timeStamp; // get offset time   
    collectData(); // send data   
    cur_on = 0;
  }  
}

// Send data in binary to increase speed and reduce buffer overflow
void sendBinary(int value) 
// Send a binary value directly (without conversion to string)
// based on http://my.safaribooksonline.com/book/hobbies/9781449399368/serial-communications/sending_binary_data_from_arduino#X2ludGVybmFsX0ZsYXNoUmVhZGVyP3htbGlkPTk3ODE0NDkzOTkzNjgvMTAy
{
  Serial.write(lowByte(value));
  Serial.write(highByte(value));
}
